generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum MemberType {
  MEMBER
  GUEST
}

enum UserRole {
  MEMBER
  ADMIN
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
}

enum PaymentMethod {
  PAYSTACK
  EFT
}

model User {
  id                     String               @id @default(cuid())
  clerkId                String?              @unique
  email                  String               @unique
  memberNumber           Int                  @unique @default(autoincrement())
  firstName              String?
  lastName               String?
  memberType             MemberType           @default(GUEST)
  role                   UserRole             @default(MEMBER)
  customRoleId           String?
  customRole             Role?                @relation(fields: [customRoleId], references: [id])
  isActive               Boolean              @default(true)
  zoneId                 String?
  zone                   Zone?                @relation(fields: [zoneId], references: [id])
  streetId               String?
  street                 Street?              @relation(fields: [streetId], references: [id])
  houseNumber            String?
  section                String?
  hideFromNeighbours     Boolean              @default(false)
  patrolOptIn            Boolean              @default(false)
  secondaryContactName   String?
  secondaryContactPhone  String?
  secondaryContactEmail  String?
  isApproved             Boolean              @default(false)
  emailPrefs             Json?
  whatsappOptIn          Boolean              @default(false)
  whatsappPhone          String?
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
  incidents              Incident[]
  eventRsvps             EventRsvp[]
  businessListings       BusinessListing[]
  businessMessages       BusinessMessage[]
  businessEventRsvps     BusinessEventRsvp[]
  businessReferrals      BusinessReferral[]
  businessIntroRequests  BusinessIntroRequest[]
  conversationParticipants ConversationParticipant[]
  sentInboxMessages        InboxMessage[]           @relation("sentMessages")
  membershipPayments       MembershipPayment[]

  @@index([customRoleId])
}

// ── Membership Payments ─────────────────────────────────────────────────

model MembershipPayment {
  id                 String        @id @default(cuid())
  userId             String
  user               User          @relation(fields: [userId], references: [id])
  amount             Int
  currency           String        @default("ZAR")
  method             PaymentMethod
  status             PaymentStatus @default(PENDING)
  paystackReference  String?       @unique
  paystackAccessCode String?
  paidAt             DateTime?
  verifiedAt         DateTime?
  verifiedById       String?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@index([userId])
  @@index([status])
}

// ── RBAC ────────────────────────────────────────────────────────────────

model Role {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  isSystem    Boolean          @default(false)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  users       User[]
  permissions RolePermission[]
}

model Permission {
  id          String           @id @default(cuid())
  key         String           @unique
  label       String
  groupName   String
  description String?
  roles       RolePermission[]
}

model RolePermission {
  roleId       String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

model Incident {
  id          String   @id @default(cuid())
  type        String
  location    String
  dateTime    DateTime
  zoneId      String?
  zone        Zone?    @relation(fields: [zoneId], references: [id])
  reportedBy  String?
  createdById String?
  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
}

model Zone {
  id              String           @id @default(cuid())
  name            String
  postcodePrefix  String?
  mapUrl          String?
  boundary        Json?
  members         User[]
  incidents       Incident[]
  streets         Street[]
  businessListings BusinessListing[]
}

model Street {
  id      String  @id @default(cuid())
  name    String
  zoneId  String
  zone    Zone    @relation(fields: [zoneId], references: [id])
  section String?
  order   Int     @default(0)
  users   User[]

  @@unique([zoneId, name])
}

model Event {
  id        String      @id @default(cuid())
  title     String
  location  String
  startAt   DateTime
  endAt     DateTime?
  content   String?
  createdAt DateTime    @default(now())
  rsvps     EventRsvp[]
}

model EventRsvp {
  id        String   @id @default(cuid())
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@unique([eventId, userId])
}

model DocumentCategory {
  id   String     @id @default(cuid())
  name String
  docs Document[]
}

model Document {
  id         String           @id @default(cuid())
  name       String
  categoryId String
  category   DocumentCategory @relation(fields: [categoryId], references: [id])
  fileUrl    String
  createdAt  DateTime         @default(now())
}

model CommitteeMember {
  id    String  @id @default(cuid())
  role  String
  name  String
  phone String?
  email String?
  order Int
}

model EmergencyContact {
  id      String @id @default(cuid())
  service String
  number  String
  order   Int
}

enum SponsorTier {
  PREMIUM
  PARTNER
  SUPPORTER
}

model Sponsor {
  id       String      @id @default(cuid())
  name     String
  content  String?
  linkUrl  String?
  logoUrl  String?
  tier     SponsorTier @default(PARTNER)
  order    Int
}

model ContactMessage {
  id        String   @id @default(cuid())
  name      String
  email     String
  message   String   @db.Text
  createdAt DateTime @default(now())
}

model SafetyTip {
  id        String   @id @default(cuid())
  title     String
  slug      String   @unique
  category  String
  summary   String?  @db.Text
  content   String   @db.Text
  order     Int      @default(0)
  updatedAt DateTime @updatedAt
}

model VolunteerInterest {
  id            String   @id @default(cuid())
  name          String
  email         String
  phone         String?
  roleInterest  String
  zoneId        String?
  availability  String?  @db.Text
  message       String?  @db.Text
  createdAt     DateTime @default(now())
}

model VacationWatch {
  id                  String   @id @default(cuid())
  name                String
  address             String
  contactPhone        String
  awayFrom            DateTime
  awayUntil           DateTime
  emergencyContact    String?
  specialInstructions String?  @db.Text
  createdAt           DateTime @default(now())
}

model SchemeInquiry {
  id        String   @id @default(cuid())
  name      String
  email     String
  phone     String?
  address   String?
  message   String?  @db.Text
  createdAt DateTime @default(now())
}

enum BusinessListingStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BusinessCategory {
  RETAIL
  SERVICES
  FOOD
  HEALTH
  OTHER
}

model BusinessListing {
  id          String               @id @default(cuid())
  name        String
  description String               @db.Text
  category    BusinessCategory
  address     String?
  phone       String?
  email       String
  websiteUrl  String?
  logoUrl     String?
  zoneId      String?
  zone        Zone?                @relation(fields: [zoneId], references: [id])
  status      BusinessListingStatus @default(PENDING)
  featured    Boolean              @default(false)
  createdById String?
  createdBy   User?                @relation(fields: [createdById], references: [id])
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  messages    BusinessMessage[]
  events      BusinessEvent[]
  referrals      BusinessReferral[]
  introRequests  BusinessIntroRequest[]
  conversations  Conversation[]
}

model BusinessMessage {
  id        String         @id @default(cuid())
  listingId String
  listing   BusinessListing @relation(fields: [listingId], references: [id])
  senderId  String
  sender    User           @relation(fields: [senderId], references: [id])
  body      String         @db.Text
  readAt    DateTime?
  createdAt DateTime       @default(now())
}

model BusinessEvent {
  id          String               @id @default(cuid())
  title       String
  description String?              @db.Text
  location    String
  startAt    DateTime
  endAt      DateTime?
  listingId  String?
  listing    BusinessListing?      @relation(fields: [listingId], references: [id])
  createdAt  DateTime             @default(now())
  rsvps      BusinessEventRsvp[]
}

model BusinessEventRsvp {
  id        String       @id @default(cuid())
  eventId   String
  event     BusinessEvent @relation(fields: [eventId], references: [id])
  userId    String
  user      User         @relation(fields: [userId], references: [id])
  createdAt DateTime     @default(now())

  @@unique([eventId, userId])
}

model BusinessReferral {
  id             String         @id @default(cuid())
  listingId     String
  listing       BusinessListing @relation(fields: [listingId], references: [id])
  referrerId    String
  referrer      User           @relation(fields: [referrerId], references: [id])
  referredName  String
  referredEmail String
  message       String?        @db.Text
  createdAt     DateTime       @default(now())
}

enum BusinessIntroRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model BusinessIntroRequest {
  id             String                    @id @default(cuid())
  requesterId    String
  requester      User                      @relation(fields: [requesterId], references: [id])
  targetListingId String
  targetListing  BusinessListing           @relation(fields: [targetListingId], references: [id])
  message        String                    @db.Text
  status         BusinessIntroRequestStatus @default(PENDING)
  createdAt      DateTime                  @default(now())
}

// ── Inbox Messaging ─────────────────────────────────────────────────────

enum ConversationType {
  DIRECT
  SYSTEM
  BUSINESS
  ADMIN_BROADCAST
}

model Conversation {
  id                String                   @id @default(cuid())
  subject           String?
  type              ConversationType         @default(DIRECT)
  businessListingId String?
  businessListing   BusinessListing?         @relation(fields: [businessListingId], references: [id])
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  messages          InboxMessage[]
  participants      ConversationParticipant[]
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  lastReadAt     DateTime?
  isArchived     Boolean      @default(false)
  isDeleted      Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@unique([conversationId, userId])
  @@index([userId, isDeleted])
}

model InboxMessage {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String?
  sender         User?        @relation("sentMessages", fields: [senderId], references: [id])
  body           String       @db.Text
  metadata       Json?
  createdAt      DateTime     @default(now())

  @@index([conversationId, createdAt])
}
